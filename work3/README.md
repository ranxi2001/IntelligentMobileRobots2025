# 作业3：ROS2实现激光雷达地图生成

## 项目概述

本项目是基于ROS2框架实现的激光雷达地图生成系统，通过处理激光雷达数据和里程计数据，构建环境的占用栅格地图。系统通过一系列参数优化，能够生成高质量的地图，准确表示环境中的障碍物和自由空间。

## 环境要求

- ROS2 Humble（或更新版本）
- Python 3.8+
- NumPy, Matplotlib
- 足够的内存（建议4GB以上）用于大型地图的生成

## 功能特点

1. **数据转换**：将原始LMS激光雷达数据和NAV轨迹数据转换为ROS2标准格式
2. **实时地图生成**：接收激光和里程计数据，实时更新占用栅格地图
3. **参数化设计**：提供丰富的参数配置，便于调整地图生成效果
4. **运动过滤**：识别机器人静止状态，避免噪声累积
5. **自适应阈值**：根据障碍物距离动态调整检测阈值
6. **地图可视化**：生成直观的地图图像，显示障碍物和机器人轨迹

## 目录结构

```
work3/
├── setup.sh                   # 工作空间设置脚本
├── run.sh                     # 运行脚本
├── 01_create_bag.sh           # 数据转换脚本
├── 02_play_bag.sh             # 回放bag数据脚本
├── 03_map_generation.sh       # 地图生成脚本
├── src/                       # 源代码目录
│   ├── lms_data/              # 数据转换包
│   │   ├── lms_data/
│   │   │   └── lms_to_rosbag.py  # 数据转换节点
│   │   ├── package.xml
│   │   └── setup.py
│   └── lms_mapper/            # 地图生成包
│       ├── lms_mapper/
│       │   └── lms_mapper_node.py  # 地图生成节点
│       ├── package.xml
│       └── setup.py
└── README.md                  # 项目说明文件
```

## 功能模块详解

### 1. 数据转换模块 (lms_data)

将原始的LMS激光雷达数据和NAV轨迹数据转换为ROS2标准消息格式，并保存为rosbag文件：

- 激光数据转换为 `sensor_msgs/LaserScan` 消息
- 轨迹数据转换为 `nav_msgs/Odometry` 消息和 `tf2_msgs/TFMessage` 消息
- 创建了 `/scan`、`/odom` 和 `/tf` 三个标准ROS2话题

主要流程：
1. 读取原始数据文件
2. 解析数据并转换为标准ROS2消息格式
3. 写入rosbag文件

### 2. 栅格地图生成模块 (lms_mapper)

接收rosbag数据，进行激光数据处理和占用栅格地图生成：

- 订阅 `/scan` 和 `/odom` 话题
- 将激光数据从激光坐标系转换到全局坐标系
- 使用逆传感器模型更新占用栅格地图
- 定期发布 `/map` 话题 (nav_msgs/OccupancyGrid)
- 将栅格地图保存为图像文件

主要特性：
- **运动过滤**：只在机器人移动时记录障碍物，避免静止时的噪声
- **自适应阈值**：根据障碍物距离动态调整检测阈值
- **坐标转换**：精确的坐标系转换确保准确的地图构建
- **周期性地图保存**：定期保存地图状态，便于查看地图生成过程

## 参数调优指南

地图生成模块提供了丰富的参数配置，可以根据不同环境和需求进行调整：

### 关键参数说明

| 参数名 | 说明 | 默认值 | 建议范围 |
|-------|------|-------|---------|
| map_threshold | 障碍物检测阈值 | 3 | 2-6 |
| min_motion_distance | 最小运动距离 | 0.5 | 0.3-0.7 |
| static_ignore_time | 静止忽略时间 | 0.2 | 0.1-0.5 |
| base_threshold | 基础阈值 | 2 | 1-4 |
| distance_threshold_factor | 距离因子 | 0.5 | 0.3-0.9 |
| size_x, size_y | 地图大小 | 1000 | 500-1500 |
| resolution | 地图分辨率 | 0.1 | 0.05-0.2 |

### 参数优化建议

1. **转弯处障碍物不清晰**
   - 降低 `map_threshold` 和 `base_threshold`
   - 减小 `distance_threshold_factor`

2. **静止时累积过多点**
   - 增加 `min_motion_distance`
   - 减少 `static_ignore_time`

3. **远处障碍物不可见**
   - 降低 `distance_threshold_factor`
   - 减小 `base_threshold`

4. **地图范围不足**
   - 增加 `size_x` 和 `size_y`
   - 调整 `resolution`

## 运行指南

### 完整流程

在工作目录中执行以下命令：

```bash
# 1. 确保脚本可执行
chmod +x setup.sh run.sh

# 2. 执行运行脚本（一键完成全部流程）
./run.sh
```

脚本将自动执行以下步骤：
1. 创建ROS2工作空间结构
2. 构建ROS2包
3. 将原始数据转换为rosbag格式
4. 启动地图生成节点
5. 播放rosbag数据
6. 生成并保存占用栅格地图

### 分步运行

也可以分步执行以便调试：

```bash
# 1. 设置工作空间
./setup.sh

# 2. 创建rosbag数据
./01_create_bag.sh

# 3. 启动地图生成节点
./03_map_generation.sh

# 4. 在另一个终端中播放数据
./02_play_bag.sh
```

## 输出结果

成功执行后，将生成以下文件：
- `lms_data.bag`: 转换后的ROS2 bag数据文件
- `occupancy_grid.png`: 最终的占用栅格地图图像
- `map_checkpoint_*.png`: 地图生成过程中的检查点图像
- `robot_trajectory.png`: 机器人轨迹图像

## 参数调优过程

为了获得高质量的地图，我们进行了多轮参数调优：

### 初始参数设置
- `map_threshold`: 6
- `min_motion_distance`: 0.4
- `static_ignore_time`: 0.5
- `base_threshold`: 4
- `distance_threshold_factor`: 0.9

### 遇到的问题
- 初始位置累积了过多的障碍点
- 转弯处障碍物不够清晰
- 部分区域障碍物缺失

### 最终优化参数
- `map_threshold`: 3（降低阈值，使转弯处障碍物更清晰）
- `min_motion_distance`: 0.5（增加最小运动距离，减少静止时记录的点）
- `static_ignore_time`: 0.2（更快识别为静止状态）
- `base_threshold`: 2（降低基础阈值，使转弯处显示更多障碍点）
- `distance_threshold_factor`: 0.5（降低距离因子，远处障碍物也能更好地被检测）

## 常见问题与解决方案

1. **地图范围不足**
   - 增加 `size_x` 和 `size_y` 参数
   - 调整 `resolution` 参数

2. **静止时累积过多障碍点**
   - 检查 `min_motion_distance` 和 `static_ignore_time` 参数
   - 确保运动过滤功能正常工作

3. **转弯处障碍物不清晰**
   - 降低 `map_threshold` 和 `base_threshold`
   - 减小 `distance_threshold_factor`

4. **障碍物点过于稀疏**
   - 检查激光数据格式和频率
   - 降低 `map_threshold` 参数

## 坐标范围与分辨率分析

### 坐标转换机制

世界坐标到栅格坐标的转换存在一个关键限制：`world_to_grid`函数将坐标限制在`(0, 0)`到`(size_x-1, size_y-1)`的范围内。这意味着：

- 如果地图原点`(origin_x, origin_y)`设置在地图中心`(map_size//2, map_size//2)`，超出地图范围的点会被截断
- 分辨率参数`resolution`直接影响世界坐标到栅格坐标的转换比例（世界坐标需要除以分辨率才能转换为栅格坐标）

### 地图尺寸与分辨率关系

以下是不同配置的分析：

#### 当前配置
- 地图尺寸：1000×1000格
- 分辨率：0.1米/格
- 理论覆盖范围：100米（从地图中心向四周各延伸50米）

#### 优化方案
1. **高精度方案**
   - 分辨率：0.05米/格
   - 覆盖范围：50米（从中心向四周延伸25米）
   - 优点：细节更清晰
   - 缺点：可能不足以覆盖全部区域

2. **平衡方案**
   - 分辨率：0.08米/格
   - 覆盖范围：80米（从中心向四周延伸40米）
   - 优点：平衡了细节和覆盖范围
   - 缺点：略微降低了覆盖范围，但仍足够

3. **优化内存方案**
   - 地图尺寸：800×800格
   - 分辨率：0.075米/格
   - 覆盖范围：60米（从中心向四周延伸30米）
   - 优点：提高了清晰度，降低了内存消耗（相比1000×1000的地图减少了36%的内存占用）

### 建议配置

根据分析，建议将分辨率设置为0.075米/格，同时将地图尺寸调整为800×800格。这个组合能够：
- 覆盖大约±30米的区域，足够显示当前环境
- 提供足够的细节清晰度
- 优化内存使用和计算效率

## ROS2相关技术应用

本作业应用了以下ROS2技术：

1. **ROS2包结构**: 使用标准的ROS2 Python包结构
2. **消息类型**: 使用标准ROS2消息类型进行通信
3. **节点通信**: 实现了发布者/订阅者模式
4. **参数系统**: 使用ROS2参数系统配置节点行为
5. **rosbag2**: 使用rosbag2进行数据记录和回放
6. **坐标变换**: 使用tf2实现坐标系转换

## 与ROS1版本的对比

与ROS1相比，ROS2具有以下优势：

1. **实时性**: 基于DDS中间件，提供更好的实时性能
2. **安全性**: 提供内置的安全功能
3. **跨平台**: 支持更多操作系统
4. **模块化**: 更加模块化的设计
5. **QoS**: 提供服务质量设置
6. **多节点支持**: 更好的多节点、多进程支持

## 基本要求
- 选择之前完成的作业1或作业2中的一个任务（**选择作业2将获得加分**）
- 使用ROS2框架重新实现该任务
- 完成以下两个关键步骤：
  1. 编写代码将原始数据转换为rosbag格式
  2. 编写ROS2节点，接收rosbag数据并实现对应功能

## 技术要求
- 编程语言：Python/C/C++均可
- 需使用ROS2最新稳定版本
- 代码应遵循ROS2的标准规范

## 提交内容
- 完整源代码（包含注释）
- 技术报告（至少1页）：
  - 描述实现思路
  - 说明ROS2节点设计
  - 展示运行结果
  - 与ROS1版本对比（如有）

## 截止日期
- 2024年3月23日

## 参考资源
- [ROS2官方文档](https://docs.ros.org/en/humble/index.html)
- [ROS2 Tutorials](https://docs.ros.org/en/humble/Tutorials.html)
- [rosbag2使用指南](https://docs.ros.org/en/humble/Tutorials/Ros2bag/Recording-And-Playing-Back-Data.html)